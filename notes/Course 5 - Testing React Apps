## Log in to frontend
#### Conditional Login of a login form
```jsx
const App = () => {
  // ...
  const loginForm = () => (
    // ...
  )
  const noteForm = () => (
    // ...
  )

  return (
    <div>
      <h1>Notes</h1>
      <Notification message={errorMessage} />

      {!user && loginForm()}      
      {user && noteForm()}
  )
```
- Only renders the component if previous value true.
#### Saving token to browser
- If we refresh we use all state including token
```js
window.localStorage.setItem('name', 'juha tauriainen')
```
- Saves to browser key:pair database
- Pulled with 
```js
window.localStorage.getItem('name')
```
- `removeItem()` removes it
- Only stores json, must be converted then reconverted
- Canv view databse in web console `window.localStorage`
```js
const handleLogin = async (event) => {
    event.preventDefault()
    try {
        const user = await loginService.login({ username, password })

        window.localStorage.setItem('loggedNoteappUser', JSON.stringify(user)) 
```
- Might need a proxy if we are hosting on the same device
- In vite config
```js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],

  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true,
      },
    }
  },
})
```
- Any request to `localhost:5437/api` will be redirected to `localhost:3001` where express server is 

## Props.children and prototpyes
- Say we want to have expandable forms to save screen space
```jsx
const App = () => {

  const [loginVisible, setLoginVisible] = useState(false)

  // ...

  const loginForm = () => {
    const hideWhenVisible = { display: loginVisible ? 'none' : '' }
    const showWhenVisible = { display: loginVisible ? '' : 'none' }

    return (
      <div>
        <div style={hideWhenVisible}>
          <button onClick={() => setLoginVisible(true)}>log in</button>
        </div>
        <div style={showWhenVisible}>
          <LoginForm
          // ...
          />
          <button onClick={() => setLoginVisible(false)}>cancel</button>
        </div>
      </div>
    )
  }

  // ...
}
```
- This uses `sytle:none` to hide a component via css
#### Making a toggleable component
```jsx
import { useState } from 'react'

const Togglable = (props) => {
  const [visible, setVisible] = useState(false)

  const hideWhenVisible = { display: visible ? 'none' : '' }
  const showWhenVisible = { display: visible ? '' : 'none' }

  const toggleVisibility = () => {
    setVisible(!visible)
  }

  return (
    <div>
      <div style={hideWhenVisible}>
        <button onClick={toggleVisibility}>{props.buttonLabel}</button>
      </div>
      <div style={showWhenVisible}>
        {props.children} // Inserts embedded react component children inside toggleable class
        <button onClick={toggleVisibility}>cancel</button>
      </div>
    </div>
  )
}

export default Togglable
```
#### State in forms
Put state in forms compnent instead of App.jsx!!!
#### Ref
Create ref and link it to a component
```jsx
import { useState, useEffect, useRef } from 'react'

const App = () => {
  // ...

  const noteFormRef = useRef()

  const noteForm = () => (

    <Togglable buttonLabel='new note' ref={noteFormRef}>
      <NoteForm createNote={addNote} />
    </Togglable>
  )

  // ...
}
```
LINK THROUGH RENDERS
```jsx
  useImperativeHandle(props.ref, () => {    
    return { toggleVisibility }  
  })
  ```
Call with:
  ```jsx
  const App = () => {
  // ...
  const addNote = (noteObject) => {

    noteFormRef.current.toggleVisibility()
    noteService
      .create(noteObject)
      .then(returnedNote => {     
        setNotes(notes.concat(returnedNote))
      })
  }
  // ...
}
```
## Testing React Apps
- Can use `ViteTest` for component testing
```bash
npm install --save-dev vitest jsdom
npm install --save-dev @testing-library/react @testing-library/jest-dom
```
- Add `"test": "vitest run"` to `scripts:` in `package.json`
- Make a new file, `testSetup.js`
```js
import { afterEach } from 'vitest'
import { cleanup } from '@testing-library/react'
import '@testing-library/jest-dom/vitest'

afterEach(() => {
  cleanup()
})
```
- Add env to `vite.config.js`
```js
export default defineConfig({
  // ...
  test: {
    environment: 'jsdom',
    globals: true, // Makes us not need describe, test, expect
    setupFiles: './testSetup.js', 
  }
})
```
#### Rendering component
- Write test for `src/components/Note.test.jsx`, same dir as Note.jsx
   - Can keep them in a seperate folder. Preference
```jsx
import { render, screen } from '@testing-library/react'
import Note from './Note'

test('renders content', () => {
  const note = {
    content: 'Component testing is done with react-testing-library',
    important: true
  }

  render(<Note note={note} />)

  const element = screen.getByText('Component testing is done with react-testing-library')
  expect(element).toBeDefined()
})
```
- Dont actually need `expect()`, `getByText()` is already a test that can fail
- `getByText(param)` looks for component with ONLY param
- `findByText(param)` looks for component including param, RETURNS A PROMISE so await
- `queryByText()` same as find, but doesnt throw exception
- `getTestById()` you get it.
#### Debugging
- `screen.debug()` prints html of screen to console
- `screen.debug(element)` ^^^ of element to console
To simulate user input:
`npm install --save-dev @testing-library/user-event`
```jsx
import { render, screen } from '@testing-library/react'

import userEvent from '@testing-library/user-event'
import Note from './Note'

// ...

test('clicking the button calls event handler once', async () => {
  const note = {
    content: 'Component testing is done with react-testing-library',
    important: true
  }

  const mockHandler = vi.fn() // comes from vitest

  render(<Note note={note} toggleImportance={mockHandler} />)

  const user = userEvent.setup() // session start
  const button = screen.getByText('make not important')
  await user.click(button) // click button

  expect(mockHandler.mock.calls).toHaveLength(1) // Array of calls is len(one) "has only been called once"
})
```

#### Testing Forms
Testing a NoteForm:
```jsx
import { render, screen } from '@testing-library/react'
import NoteForm from './NoteForm'
import userEvent from '@testing-library/user-event'

test('<NoteForm /> updates parent state and calls onSubmit', async () => {
  const createNote = vi.fn()
  const user = userEvent.setup()

  render(<NoteForm createNote={createNote} />)

  const input = screen.getByRole('textbox')
  const sendButton = screen.getByText('save')

  await user.type(input, 'testing a form...')
  await user.click(sendButton)

  expect(createNote.mock.calls).toHaveLength(1)
  expect(createNote.mock.calls[0][0].content).toBe('testing a form...')
})
```
What about 2 inputs?
```jsx
const inputs = screen.getAllByRole('textbox')

await user.type(inputs[0], 'testing a form...')
```
Or if placeholder text is present
```jsx
<input
//...
placeholder='write note content here'
/>
```
- Use `const input = screen.getByPlaceholderText('write note content here')`
#### Test coverage?
- `npm test -- --coverage`
- Will need to add /coverage to .gitignore

